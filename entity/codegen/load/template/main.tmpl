{{ define "main" }}
// Code generated by 'entc generate'. DO NOT EDIT.
package main

import (
	"os"
	"bytes"
	{{ template "imports" }}

	entityPkg {{ printf "%q" .Package }}
)

var databases = map[string]entity.DbInterface{
	{{- range $db := .Config.Dbs }}
		{{ printf "%q" $db.Name }}: &entityPkg.{{ $db.Name }}{},
	{{- end }}
}

type EntityMap map[string]string

var dbEntities = map[string]EntityMap{
	{{- range $db := .Config.Dbs }}
		{{ printf "%q" $db.Name }}: EntityMap{
			{{- range  $key, $type := $db.Entities }}
				{{ printf "%q" $key }}: {{ printf "%q" $type }},
			{{- end }}
		},
	{{- end }}
}

var entities = map[string]entity.EntityInterface{
	{{- range $name := .Config.Entities }}
		{{ printf "%q" $name }}: &entityPkg.{{ $name }}{},
	{{- end }}
}

func main() {
	var lines [][]byte
	for name, database := range databases {
		entities := dbEntities[name]
		b, err := Marshal(database,name, entities)
		if err != nil {
			fail(err)
		}
		lines = append(lines, b)
	}
	os.Stdout.Write(bytes.Join(lines, []byte("\n")))
}

// 序列化用户的package中的entity,
// 把[entity.EntityInterface]中的方法的返回值都序列化到Entity中
//
// Params:
//
//	- di: 数据库接口
//	- de: 数据库中的entity
func Marshal(di entity.DbInterface,name string, de EntityMap) (b []byte, err error) {
	config := di.Config()
	if config.Tag == "" {
		return nil, fmt.Errorf("taurus_go/entity %q: Database config missing Tag name.", reflect.TypeOf(di).Elem().Name())
	}
	if config.Type == "" || (config.Type != dialect.PostgreSQL) {
		return nil, fmt.Errorf("taurus_go/entity %q:Database config missing Type '%s', please make sure the entity.DbConfig.Type is correct.", reflect.TypeOf(di).Elem().Name(),config.Type)
	}
	if config.Name == "" {
		config.Name = name
	}
	database := &Database{
		Name: config.Name,
		Tag:     config.Tag,
		Type:  	  config.Type,
		EntityMap: map[string]string{},
		Entities: 	map[string]*Entity{},
		Triggers: config.Triggers,
	}
	v := reflect.ValueOf(di).Elem()
	for key, entityName := range de {
		e := entities[entityName]
		db = database
		me, err := MarshalEntity( e)
		if err != nil {
			return nil, err
		}
		for _, _e := range database.Entities {
			if _e.AttrName == me.AttrName {
				return nil,entity.Err_0100020020.Sprintf(me.AttrName)
			}
		}
		database.EntityMap[key] = entityName
		database.Entities[entityName] = me
		field := v.FieldByName(key)
		if field.IsValid() {
			  // 确保传递给 Set 方法的值与字段的类型匹配
			if field.Type().Kind() == reflect.Ptr {
				field.Set(reflect.ValueOf(e)) // e 已经是指针类型
			} else {
				field.Set(reflect.ValueOf(e).Elem()) // 获取 e 指向的值
			}
		} else {
			// 处理无效字段的情况，例如打印错误信息或返回错误
			fmt.Printf("Field %q not found in type %T\n", entityName, di)
		}
	}
	err = database.loadRelationship(di)
	if err != nil {
		return nil, err
	}

	return json.Marshal(database)
}



func fail(err error) {
	os.Stderr.WriteString(err.Error()+"\n")
	os.Exit(1)
}

{{ template "entity" }}

{{ end }}
